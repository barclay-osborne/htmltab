---
title: "Hassle-free HTML tables with htmltable"
author: "Christian Rubba"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

## htmltable
HTML tables are a standard way to display tabular information on the internet. Parsing and transforming HTML tables into R objects is very straightforward with the `readHTMLTable()` function of the *XML* package. But tables on the web are primarily designed for display and consumption of data, and not for analytical purposes. Peculiar design choices for HTML tables are thus oftentimes made which tend to produce useless outputs when run through `readHTMLTable()`. I found that sometimes these outputs could be saved with a little bit of (tedious) post-processing. *htmltable* is a package for the R system that tries to alleviate these problems directly in the parsing stage when structural information are still available. Its main advantages over `readHTMLTable()` are twofold:

- Consideration of row and column spans in HTML table body and header
- Finer control over the conversion process from HTML table cells to R table cells

This vignette discusses the application of *htmltable* for two use cases where the package provides a significant improvement over `readHTMLTable()`. 

(This vignette uses the R packages *magrittr* and *tidyr* to process table outputs. Neither of the two is required for running *htmltable*.)

## How to read HTML tables with htmltable()
The principle function of *htmltable* is (surprise!) `htmltable()`. The behaviour of `htmltable()` is very closely modelled after `readHTMLtable()`'s, and most argument names are the same. Any function call requires passing a value to its _doc_ argument. This may be one of three kinds:

1. a URL/file path for the page where the table(s) lives
2. a parsed HTML object of the entire page
3. a list of XML \<table\> node(s).

Similiar to `readHTMLTable()`, passing an URL returns a list of all tables in the page. Passing the parsed page XML object does the same. The return value for both of these use cases is a list of one or multiple tables. When only the table node is provided, `htmltable()` returns that single table. For the first two methods, you can additionally pass a value to the _which_ argument to specify the exact table. This may be either a numeric value for the table's rank in the page, or a character value that describes an XPath statement. For the sake of brevity, in this vignette the third method is used. 

```{r, echo = FALSE, results = "hide"}
library(htmltable)
library(magrittr)
library(XML)
```


## 1. Corrections for rowspans and colspans by default
In many HTML tables, spans are used to allow cell values to extend over multiple cells. `htmltable()` recognizes spans and expands these tables automatically. To illustrate this feature, take a look at the HTML table in the Language section on this [Wikipedia page about Demography in the UK](en.wikipedia.org/wiki/Demography_of_the_United_Kingdom.html#Languages). Header information span over three consecutive rows. To get this table into R, we have to pass an identifiying information to the _which_ argument. Here, I use an XPath statement that I came up with during exploration of the HTML page with Web Developer Tools. One that works here is "//table[12]" (passing 12 would have resulted in the same output). 

```{r}
url <- "http://en.wikipedia.org/wiki/Demography_of_the_United_Kingdom"
ukLang <- htmltable(doc = url, num = "//table[12]")
head(ukLang)
```

The header information have been recast into a format that respects the hierarchical order of the variables and yet only spans a single line in the R table. If you prefer a different seperator between variables, pass it to the _headerSep_ argument. This format was mainly chosen to make further processing of the table really easy. For example, using functionality from the *tidyr* package, the next couple of data cleaning step may be the following:

```{r, fig.show='hold'}
library(tidyr)
library(magrittr)

ukLang <- ukLang %>% gather(key, value, -Ability)
```

This gathers the variables into a more useful long format. From this we can separate the variables using an appropriate regular expression such as " >[0-9]> ". 

```{r, fig.show='hold'}
ukLang %>% separate(key, into = c("region", "language", "statistic"), sep = " >[0-9]> ") %>% head
```

`htmltable()` also automatically expands row and column spans when they appear in the table's body. 

## 2. More control over cell value conversion
With `htmltable()` you have fine control over what part of the HTML table is used for the final R table. You can exert this control through `htmltables()`'s _body_, _header_ and _elFun_ arguments. 

### _body_ and _header_ arguments
These arguments are used to pass information about which rows should be used for the contruction of the header and the body. Both accept numeric values for the rows, but a more robust way is to use an XPath that identifies the respective rows. To illustrate, take a look at this [Wikipedia page about the New Zealand General Election in 2002](http://en.wikipedia.org/wiki/New_Zealand_general_election,_2002#Electorate_results). This table uses in-table all columns spanning cells to classify General and Maori electorates (yellow background). This is a problem that we need to control for explicitly in the assembling stage. Here, I pass the XPath "tr[./td[not(@colspan = '10')]]" to the _body_ argument to explicitly discard all rows from the body that have a \<td\> cell with a colspan attribute of 10:

```{r, fig.show='hold'}
url <- "http://en.wikipedia.org/wiki/New_Zealand_general_election,_2002"
nz1 <- htmltable(doc = url, num = 4, body = "tr[./td[not(@colspan = '10')]]")
head(nz1)
```



You rightly object that ideally these rows should not be discarded, but used for what they are -- variable/header information! I hope to include more control over in-table variables in a future version of this package.

### _elFun_ argument
_cellFun_ is similiar to `readHTMLtable()`'s _elFun_ but doesn't assume that users are only interested in a cell's XML value. Instead, you  are free to define a function over the entire cell node (including \<td\>'s and/or \<th\>'s). This can be necessary when valuable information are stored in an element's attributes. In the previous example, colours are used to depict the incumbent party and this information may be of interest to use. The colour information are not stored as cell values but as style attributes. The following function _col\_party_ extracts the cell values, but if this value is found to be empty it extracts the style attributes and translates the colours into sensible party labels:

```{r, fig.show='hold'}
col_party <- function(node) {
  library(stringr)
  
  x <- xmlValue(node)

	if(x == ""){
    x <- xmlGetAttr(node, "style")
    
    if(str_detect(x, "#098137")){
      x <- "Greens"}
    if(str_detect(x, "#00529F")){
      x <- "National"}
    if(str_detect(x, "#FF0000")){
      x <- "Labour"}
    if(str_detect(x, "#501557")){
      x <- "United Future"}
    if(str_detect(x, "#000000")){
      x <- "New Zealand First"}
    if(str_detect(x, "#AB0616")){
      x <- "Progressive"}
    if(str_detect(x, "#9E9E9E")){
      x <- "independent"}
  }
  
  return(x)
}
```

We can now simply pass this function to the _elFun_ argument:

```{r, fig.show='hold'}
nz2 <- htmltable(doc = url, num = 4, body = "tr[./td[not(@colspan = '10')]]", elFun = col_party)
head(nz2)
```


## Conclusion
HTML tables are a valuable data source but they oftentimes violate even basic principles of data well-formedness. This is usually for good reasons since their primary purpose is to increases readability of tabular information. *htmltable*'s goal is to reduce the need for users to interfere when working with HTML tables by using inherent structural information as well as making some assumption about the table's design. However, you are free to exert more control about the translation by specifying the function's arguments. 
